        -:    0:Source:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/queue.c
        -:    0:Graph:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/build/CMakeFiles/game.dir/queue.c.gcno
        -:    0:Data:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/build/CMakeFiles/game.dir/queue.c.gcda
        -:    0:Runs:238
        -:    1:#include "queue.h"
        -:    2:
        -:    3:#include <assert.h>
        -:    4:#include <stdbool.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:/* *********************************************************** */
        -:    8:
        -:    9:struct queue_s {
        -:   10:  struct element_s *head;
        -:   11:  struct element_s *tail;
        -:   12:  unsigned int length;
        -:   13:};
        -:   14:
        -:   15:/* *********************************************************** */
        -:   16:
        -:   17:struct element_s {
        -:   18:  void *data;
        -:   19:  struct element_s *next;
        -:   20:  struct element_s *prev;
        -:   21:};
        -:   22:
        -:   23:/* *********************************************************** */
        -:   24:
        -:   25:typedef struct element_s element_t;
        -:   26:
        -:   27:/* *********************************************************** */
        -:   28:
      702:   29:queue *queue_new() {
      702:   30:  queue *q = malloc(sizeof(queue));
     702*:   31:  assert(q);
      702:   32:  q->length = 0;
      702:   33:  q->tail = q->head = NULL;
      702:   34:  return q;
        -:   35:}
        -:   36:
        -:   37:/* *********************************************************** */
        -:   38:
     1602:   39:void queue_push_head(queue *q, void *data) {
    1602*:   40:  assert(q);
     1602:   41:  element_t *e = malloc(sizeof(element_t));
    1602*:   42:  assert(e);
     1602:   43:  e->data = data;
     1602:   44:  e->prev = NULL;
     1602:   45:  e->next = q->head;
     1602:   46:  if (q->head) q->head->prev = e;
     1602:   47:  q->head = e;
     1602:   48:  if (!q->tail) q->tail = e;
     1602:   49:  q->length++;
     1602:   50:}
        -:   51:
        -:   52:/* *********************************************************** */
        -:   53:
    #####:   54:void queue_push_tail(queue *q, void *data) {
    #####:   55:  assert(q);
    #####:   56:  element_t *e = malloc(sizeof(element_t));
    #####:   57:  assert(e);
    #####:   58:  e->data = data;
    #####:   59:  e->prev = q->tail;
    #####:   60:  e->next = NULL;
    #####:   61:  if (q->tail) q->tail->next = e;
    #####:   62:  q->tail = e;
    #####:   63:  if (!q->head) q->head = e;
    #####:   64:  q->length++;
    #####:   65:}
        -:   66:
        -:   67:/* *********************************************************** */
        -:   68:
      101:   69:void *queue_pop_head(queue *q) {
     101*:   70:  assert(q);
     101*:   71:  assert(q->length > 0);
     101*:   72:  if (!q->head) return NULL;
      101:   73:  void *data = q->head->data;
      101:   74:  element_t *next = q->head->next;
      101:   75:  if (next) next->prev = NULL;
      101:   76:  free(q->head);
      101:   77:  q->head = next;
      101:   78:  q->length--;
      101:   79:  if (!q->head) q->tail = NULL;  // empty list
      101:   80:  return data;
        -:   81:}
        -:   82:
        -:   83:/* *********************************************************** */
        -:   84:
    #####:   85:void *queue_pop_tail(queue *q) {
    #####:   86:  assert(q);
    #####:   87:  assert(q->length > 0);
    #####:   88:  if (!q->tail) return NULL;
    #####:   89:  void *data = q->tail->data;
    #####:   90:  element_t *prev = q->tail->prev;
    #####:   91:  if (prev) prev->next = NULL;
    #####:   92:  free(q->tail);
    #####:   93:  q->tail = prev;
    #####:   94:  q->length--;
    #####:   95:  if (!q->tail) q->head = NULL;  // empty list
    #####:   96:  return data;
        -:   97:}
        -:   98:
        -:   99:/* *********************************************************** */
        -:  100:
    #####:  101:int queue_length(const queue *q) {
    #####:  102:  assert(q);
    #####:  103:  return q->length;
        -:  104:}
        -:  105:
        -:  106:/* *********************************************************** */
        -:  107:
       88:  108:bool queue_is_empty(const queue *q) {
      88*:  109:  assert(q);
       88:  110:  return (q->length == 0);
        -:  111:}
        -:  112:
        -:  113:/* *********************************************************** */
        -:  114:
    #####:  115:void *queue_peek_head(queue *q) {
    #####:  116:  assert(q);
    #####:  117:  assert(q->head);
    #####:  118:  return q->head->data;
        -:  119:}
        -:  120:
        -:  121:/* *********************************************************** */
        -:  122:
    #####:  123:void *queue_peek_tail(queue *q) {
    #####:  124:  assert(q);
    #####:  125:  assert(q->tail);
    #####:  126:  return q->tail->data;
        -:  127:}
        -:  128:
        -:  129:/* *********************************************************** */
        -:  130:
    #####:  131:void queue_clear(queue *q) {
    #####:  132:  assert(q);
    #####:  133:  element_t *e = q->head;
    #####:  134:  while (e) {
    #####:  135:    element_t *tmp = e;
    #####:  136:    e = e->next;
    #####:  137:    free(tmp);
        -:  138:  }
    #####:  139:  q->head = q->tail = NULL;
    #####:  140:  q->length = 0;
    #####:  141:}
        -:  142:
        -:  143:/* *********************************************************** */
        -:  144:
      693:  145:void queue_clear_full(queue *q, void (*destroy)(void *)) {
     693*:  146:  assert(q);
      693:  147:  element_t *e = q->head;
     2194:  148:  while (e) {
     1501:  149:    element_t *tmp = e;
     1501:  150:    if (destroy) destroy(e->data);
     1501:  151:    e = e->next;
     1501:  152:    free(tmp);
        -:  153:  }
      693:  154:  q->head = q->tail = NULL;
      693:  155:  q->length = 0;
      693:  156:}
        -:  157:
        -:  158:/* *********************************************************** */
        -:  159:
    #####:  160:void queue_free(queue *q) {
    #####:  161:  queue_clear(q);
    #####:  162:  free(q);
    #####:  163:}
        -:  164:
        -:  165:/* *********************************************************** */
        -:  166:
      666:  167:void queue_free_full(queue *q, void (*destroy)(void *)) {
      666:  168:  queue_clear_full(q, destroy);
      666:  169:  free(q);
      666:  170:}
        -:  171:
        -:  172:/* *********************************************************** */
