        -:    0:Source:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/game.c
        -:    0:Graph:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/build/CMakeFiles/game.dir/game.c.gcno
        -:    0:Data:/mnt/c/Users/thoma/Documents/COURS/Fac/L2/Projet Tech/TD8/07B/build/CMakeFiles/game.dir/game.c.gcda
        -:    0:Runs:238
        -:    1:#include <assert.h>
        -:    2:#include <stdbool.h>
        -:    3:#include <stddef.h>
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:
        -:    8:#include "game_struct.h"
        -:    9:
     1912:   10:void *my_malloc(size_t x) {
     1912:   11:  void *y = malloc(x);
     1912:   12:  if (y == NULL) {
    #####:   13:    fprintf(stderr, "not enough memory!\n");
    #####:   14:    exit(EXIT_FAILURE);
        -:   15:  }
     1912:   16:  return (y);
        -:   17:}
        -:   18:
      351:   19:void *my_calloc(size_t nmemb, size_t size) {
      351:   20:  void *ptr = calloc(nmemb, size);
      351:   21:  if (ptr == NULL) {
    #####:   22:    fprintf(stderr, "not enough memory!\n");
    #####:   23:    exit(EXIT_FAILURE);
        -:   24:  }
      351:   25:  return ptr;
        -:   26:}
        -:   27:
   144995:   28:void check_parameters(cgame g, uint i, uint j) {
   144995:   29:  if ((g == NULL) || (i >= g->nb_rows) || (j >= g->nb_cols)) {
    #####:   30:    printf(
        -:   31:        "erreur dans les parametres, exit du programme\nVérifiez que g est non "
        -:   32:        "null, ou alors que les coordonées sont valides\n");
    #####:   33:    exit(-1);
        -:   34:  }
   144995:   35:}
        -:   36:
       18:   37:game game_new(square *squares) {
       18:   38:  return game_new_ext(DEFAULT_SIZE, DEFAULT_SIZE, squares, false, false);
        -:   39:}
        -:   40:
       60:   41:game game_new_empty(void) {
       60:   42:  return game_new_empty_ext(DEFAULT_SIZE, DEFAULT_SIZE, false, false);
        -:   43:  ;
        -:   44:}
        -:   45:
       18:   46:game game_copy(cgame g) {
       18:   47:  check_parameters(g, 0, 0);
       18:   48:  game g1 = game_new_ext(game_nb_rows(g), game_nb_cols(g), g->tab,
       18:   49:                         game_is_wrapping(g), game_is_unique(g));
       18:   50:  return g1;
        -:   51:}
        -:   52:
       66:   53:bool game_equal(cgame g1, cgame g2) {
       66:   54:  check_parameters(g1, 0, 0);
       66:   55:  check_parameters(g2, 0, 0);
      126:   56:  if (game_nb_rows(g1) != game_nb_rows(g2) ||
       60:   57:      game_nb_cols(g1) != game_nb_cols(g2))
        6:   58:    return false;
      252:   59:  for (int i = 0; i < game_nb_rows(g1); i++) {
     1218:   60:    for (int j = 0; j < game_nb_cols(g1); j++) {
     1026:   61:      if (game_get_square(g1, i, j) != game_get_square(g2, i, j)) {
       18:   62:        return false;
        -:   63:      }
        -:   64:    }
        -:   65:  }
       78:   66:  if (game_is_wrapping(g1) != game_is_wrapping(g2) ||
       36:   67:      game_is_unique(g1) != game_is_unique(g2))
        6:   68:    return false;
       36:   69:  return true;
        -:   70:}
        -:   71:
      333:   72:void game_delete(game g) {
      333:   73:  if (g != NULL) {
      333:   74:    queue_free_full(g->q_redo, free);
      333:   75:    queue_free_full(g->q_undo, free);
      333:   76:    free(g->tab);
      333:   77:    free(g);
        -:   78:  }
      333:   79:}
        -:   80:
     2720:   81:void game_set_square(game g, uint i, uint j, square s) {
     2720:   82:  check_parameters(g, 0, 0);
    2720*:   83:  assert(i < game_nb_rows(g));
    2720*:   84:  assert(j < game_nb_cols(g));
     2720:   85:  g->tab[i * game_nb_cols(g) + j] = s;
     2720:   86:}
        -:   87:
    23493:   88:square game_get_square(cgame g, uint i, uint j) {
    23493:   89:  check_parameters(g, 0, 0);
   23493*:   90:  assert(i < game_nb_rows(g));
   23493*:   91:  assert(j < game_nb_cols(g));
    23493:   92:  return g->tab[i * game_nb_cols(g) + j];
        -:   93:}
        -:   94:
     7410:   95:int game_get_number(cgame g, uint i, uint j) {
     7410:   96:  check_parameters(g, i, j);
     7410:   97:  square res = game_get_square(g, i, j);
     7410:   98:  switch (res) {
     3538:   99:    case S_IMMUTABLE_ZERO:
        -:  100:    case S_ZERO:
     3538:  101:      return 0;
        -:  102:
     3365:  103:    case S_IMMUTABLE_ONE:
        -:  104:    case S_ONE:
     3365:  105:      return 1;
        -:  106:
      507:  107:    default:
      507:  108:      return -1;
        -:  109:  }
        -:  110:}
        -:  111:
     3742:  112:int game_get_next_square(cgame g, uint i, uint j, direction dir, uint dist) {
     3742:  113:  check_parameters(g, i, j);
     3742:  114:  if (dist > 2) {
    #####:  115:    fprintf(stderr, "Unvalid parameter\n");
    #####:  116:    exit(EXIT_FAILURE);
        -:  117:  }
     3742:  118:  int nb_rows = game_nb_rows(g);
     3742:  119:  int nb_cols = game_nb_cols(g);
     3742:  120:  switch (dir) {
     1232:  121:    case UP:
     1232:  122:      if (!game_is_wrapping(g) && (int)(i - dist) < 0) {
      282:  123:        return -1;
        -:  124:      }
      950:  125:      return game_get_square(g, (nb_rows + i - dist) % nb_rows, j);
        -:  126:
      814:  127:    case DOWN:
      814:  128:      if (!game_is_wrapping(g) && (i + dist) >= nb_rows) {
      120:  129:        return -1;
        -:  130:      }
      694:  131:      return game_get_square(g, (i + dist) % nb_rows, j);
        -:  132:
     1036:  133:    case LEFT:
     1036:  134:      if (!game_is_wrapping(g) && (int)(j - dist) < 0) {
      204:  135:        return -1;
        -:  136:      }
      832:  137:      return game_get_square(g, i, (nb_cols + j - dist) % nb_cols);
        -:  138:
      660:  139:    default:
      660:  140:      if (!game_is_wrapping(g) && (j + dist) >= nb_cols) {
       90:  141:        return -1;
        -:  142:      }
      570:  143:      return game_get_square(g, i, (j + dist) % nb_cols);
        -:  144:  }
        -:  145:}
        -:  146:
     3628:  147:int game_get_next_number(cgame g, uint i, uint j, direction dir, uint dist) {
     3628:  148:  check_parameters(g, i, j);
     3628:  149:  square res = game_get_next_square(g, i, j, dir, dist);
     3628:  150:  switch (res) {
     1366:  151:    case S_IMMUTABLE_ZERO:
        -:  152:    case S_ZERO:
     1366:  153:      return 0;
        -:  154:
     1181:  155:    case S_IMMUTABLE_ONE:
        -:  156:    case S_ONE:
     1181:  157:      return 1;
        -:  158:
     1081:  159:    default:
     1081:  160:      return -1;
        -:  161:  }
        -:  162:}
        -:  163:
       30:  164:bool game_is_empty(cgame g, uint i, uint j) {
       30:  165:  check_parameters(g, i, j);
       30:  166:  if (game_get_square(g, i, j) == S_EMPTY) {
        6:  167:    return true;
        -:  168:  }
       24:  169:  return false;
        -:  170:}
        -:  171:
     1922:  172:bool game_is_immutable(cgame g, uint i, uint j) {
     1922:  173:  check_parameters(g, i, j);
     3808:  174:  if (game_get_square(g, i, j) == S_IMMUTABLE_ONE ||
     1886:  175:      game_get_square(g, i, j) == S_IMMUTABLE_ZERO) {
       84:  176:    return true;
        -:  177:  }
     1838:  178:  return false;
        -:  179:}
        -:  180:
      567:  181:int game_has_error(cgame g, uint i, uint j) {
      567:  182:  check_parameters(g, i, j);
        -:  183:
      567:  184:  direction dir[4] = {UP, DOWN, LEFT, RIGHT};
      567:  185:  int tmp = game_get_number(g, i, j);
      567:  186:  int nb_rows = game_nb_rows(g);
      567:  187:  int nb_cols = game_nb_cols(g);
      567:  188:  if (tmp == -1) {
       47:  189:    return 0;
        -:  190:  }
        -:  191:
        -:  192:  // vérfication qu'il n'y ait pas plus de 2 w/W ou b/B côte à côte
     2290:  193:  for (int k = 0; k < 4; k++) {
     2396:  194:    if (tmp == game_get_next_number(g, i, j, dir[k], 1) &&
      510:  195:        (tmp == game_get_next_number(g, i, j, dir[k], 2))) {
       92:  196:      return -1;
     1794:  197:    } else if (k == 0 || k == 2) {
     1136:  198:      if ((tmp == game_get_next_number(g, i, j, dir[k], 1)) &&
      200:  199:          (tmp == game_get_next_number(g, i, j, dir[k + 1], 1))) {
       24:  200:        return -1;
        -:  201:      }
        -:  202:    }
        -:  203:  }
        -:  204:
        -:  205:  // Partie verification S_ZERO ou S_ONE < nb_cols/2 ou nb_rows/2
      404:  206:  int cpt = 0;
     2596:  207:  for (int x = 0; x < nb_rows; x++) {
     2192:  208:    if (game_get_number(g, x, j) == tmp) {
     1010:  209:      cpt++;
        -:  210:    }
        -:  211:  }
      404:  212:  if (cpt > (nb_rows / 2)) {
       12:  213:    return -1;
        -:  214:  }
      392:  215:  cpt = 0;
     2504:  216:  for (int y = 0; y < nb_cols; y++) {
     2112:  217:    if (game_get_number(g, i, y) == tmp) {
     1032:  218:      cpt++;
        -:  219:    }
        -:  220:  }
      392:  221:  if (cpt > (nb_cols / 2)) {
       12:  222:    return -1;
        -:  223:  }
        -:  224:
        -:  225:  // Partie vérification unique
      380:  226:  if (game_is_unique(g) == true) {
        -:  227:    ////////////////////////////////////////////// comparaison des lignes
      126:  228:    int cpt_same_squares = 0;  // compteur des cases qui sont égales
      552:  229:    for (int x = 0; x < nb_rows; x++) {
      450:  230:      if (x != i) {
      576:  231:        for (int y = 0; y < nb_cols; y++) {
      552:  232:          if (game_get_number(g, i, y) == game_get_number(g, x, y)) {
      246:  233:            cpt_same_squares++;
        -:  234:          } else {
      306:  235:            cpt_same_squares = 0;
      306:  236:            break;
        -:  237:          }
        -:  238:        }
        -:  239:      }
      450:  240:      if (cpt_same_squares == nb_cols) {
       24:  241:        return -1;
        -:  242:      }
        -:  243:    }
        -:  244:    ////////////////////////////////////////////// comparaison des colonnes
      510:  245:    for (int x = 0; x < nb_cols; x++) {
      408:  246:      if (x != j) {
      408:  247:        for (int y = 0; y < nb_rows; y++) {
      408:  248:          if (game_get_number(g, y, j) == game_get_number(g, y, x)) {
      102:  249:            cpt_same_squares++;
        -:  250:          } else {
      306:  251:            cpt_same_squares = 0;
      306:  252:            break;
        -:  253:          }
        -:  254:        }
        -:  255:      }
      408:  256:      if (cpt_same_squares == nb_rows) {
    #####:  257:        return -1;
        -:  258:      }
        -:  259:    }
        -:  260:  }
      356:  261:  return 0;
        -:  262:}
        -:  263:
     1622:  264:bool game_check_move(cgame g, uint i, uint j, square s) {
     1622:  265:  check_parameters(g, 0, 0);
     1622:  266:  if (i < 0 || i >= game_nb_rows(g) || j < 0 || j >= game_nb_cols(g)) {
        6:  267:    return false;
        -:  268:  }
     1616:  269:  if (game_is_immutable(g, i, j) == true || s == S_IMMUTABLE_ONE ||
        -:  270:      s == S_IMMUTABLE_ZERO) {
       24:  271:    return false;
        -:  272:  }
     1592:  273:  return true;
        -:  274:}
        -:  275:
     1561:  276:void game_play_move(game g, uint i, uint j, square s) {
     1561:  277:  check_parameters(g, i, j);
     1561:  278:  if (game_check_move(g, i, j, s)) {
     1561:  279:    struct move *m = my_malloc(sizeof(*m));
     1561:  280:    m->row = i;
     1561:  281:    m->col = j;
     1561:  282:    m->square_prev = game_get_square(g, i, j);
     1561:  283:    game_set_square(g, i, j, s);
     1561:  284:    queue_push_head(g->q_undo, m);
        -:  285:  }
     1561:  286:}
        -:  287:
       97:  288:bool game_is_over(cgame g) {
       97:  289:  check_parameters(g, 0, 0);
      157:  290:  for (int i = 0; i < game_nb_rows(g); i++) {
      471:  291:    for (int j = 0; j < game_nb_cols(g); j++) {
      411:  292:      if (game_has_error(g, i, j) != 0 || game_get_number(g, i, j) == -1) {
       85:  293:        return false;
        -:  294:      }
        -:  295:    }
        -:  296:  }
       12:  297:  return true;
        -:  298:}
        -:  299:
        7:  300:void game_restart(game g) {
        7:  301:  check_parameters(g, 0, 0);
       53:  302:  for (int i = 0; i < game_nb_rows(g); i++) {
      322:  303:    for (int j = 0; j < game_nb_cols(g); j++) {
      276:  304:      if (!game_is_immutable(g, i, j) && game_get_number(g, i, j) != -1) {
      169:  305:        game_set_square(g, i, j, S_EMPTY);
        -:  306:      }
        -:  307:    }
        -:  308:  }
        7:  309:  queue_clear_full(g->q_redo, free);
        7:  310:  queue_clear_full(g->q_undo, free);
        7:  311:}
